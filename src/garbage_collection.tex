\newpage
\section{Предложенное решение}

\subsection{Решение без переиспользования \textit{docId}}

Каждому уникальному свойству (фичи) документа (слово/дата/маркер) присвоим
\textit{ID}. Каждому документу присвоим \textit{docId}, однозначно
соответствующий документу. Для поиска документа по \textit{docId} будем
использовать вторичный LSM индекс.

Поиск производится путем поиска в LSM-дерева, где ключом выступает
$feature\_id$ + $block\_id$, а значениями сжатые блоки битмап, в
которых индекс соответветствует \textit{docId}.

Bitmap-ы, хранящие в себе наличие либо отсутствие у документов определенных фич,
обычно сильно разрежены. Поэтому они хранятся в сжатом виде, а для удобства
использования поделены на блоки равного размера $(\sim 2^{16})$, используя
\textit{roaring bitmaps}. Сами данные в поисковом дереве расположены также по
блокам, которые однозначно определены отступом. В каждом блоке определим
переменную \textit{dangling}, содержащую количество “повисших” документов в
блоке. 

Процедура сбора мусора:
\begin{enumerate}
    \item Для каждого блока данных проверим счетчик.
    \item При достижении порогового значения счетчика проверить остальные
    документы в блоке в \textit{LSM} на валидность ключа.
    \item Присвоить живущим документам новый \textit{DocId} и обновить на него
    ссылку в \textit{LSM}-индексе.
    \item Продублировать значения битов в bitmap-ах для нового \textit{DocId}.
    \item Обнулить блок данных для старого \textit{DocId}.
\end{enumerate}

\subsection{Решение c переиспользованием \textit{docId}}

Раннее предполагалось, что документы не могут быть удалены или обновлены в
поисковом индексе и \textit{lastDocId}
никогда не дикрементировался.

Определим структуру данных, в которых будем хранить \textit{docId} повисших
документов. От структуры мы хотим быстрые поиск, добавление и удаление элементов.
Например, B-дерево (АВЛ, 2-3, B+, vEB). Назовем его \textit{dangling} дерево.

Процедура удаления/обновления документа:
\begin{enumerate}
    \item Обнулим значения битов для каждой фичи удаленного документа.
    \item Добавим \textit{docId} документа в \textit{dangling} дерево.
\end{enumerate}

Процедура добавления документа:
\begin{enumerate}
    \item Проверим, не пусто ли \textit{dangling} дерево.
    \item В случае существования "повисшей" ссылки:
    \begin{enumerate}
        \item Удаляем минимальное или рандомное значение \textit{docId} из
        \text{dangling} дерева, предварительно записав его.
        \item Записанное значение \textit{docId} присваиваем новому документу.
    \end{enumerate}
    \item В противном случае присваиваем новому документу \textit{docId} равный
    \textit{lastDocId + 1} и инкрементируем значение \textit{lastDocId}.
\end{enumerate}

\textbf{Вопрос}: требуется ли поддерживать lastDocId на каком-то пороге для
качественной работы \textit{roaring bitmaps}?

\textbf{Вопрос}: не выстрелит ли данное решение это в ногу, когда наши битмапы
перестанут "разряжаться"?
