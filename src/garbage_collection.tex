\newpage
\section{Циклический сборщик мусора}
\label{section:dangling}

Рассмотрим поисковую систему, хранилище которой основано на LSM-дереве,
использующем битмап индексы в качестве значений. Назовем \textit{первичным}
LSM-индексом индекс, состоящий из битмап документов с определенными признаками
и значениями, а \textit{вторичным} — индекс, используемый для фактического
поиска документа по \textit{docID}. Таким образом, изначально поиск документов
осуществуляется в \textit{первичном} индексе, а найденные документы проверяются
на актуальность во \textit{вторичном}.

Документ при добавлении анализируется и делится на значимые признаки вида
\textit{дата}, \textit{текст}, \textit{маркер} и другие. Каждый признак
принимает множество уникальных значений, а каждое значение однозначно определяется
\textit{ID} признака и значения. Каждому документу присваивается уникальный
\textit{docID}, соответствующий единственному объекту.

Как было указано ранее (см. с.~\pageref{table}), данные можно представить в виде
таблицы, где строка отвечает за определенный признак и его значение, а столбец
— за документ. Из-за огромного количества документов и меньшего количества
уникальных значений признаков битмапы обычно сильно разрежены, поэтому длинная
строка битмапы поделена на блоки равного размера $(\sim 2^{x})$ и хранится в
сжатом виде.

\begin{table}[H]
\caption{Логическое представление индекса}
\centering
\small
\singlespacing
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
                &       & block1&       &       & block2    &       & \ldots \\ \hline
                & doc1  & doc2  & doc3  & doc4  & doc5      & doc6  & \ldots \\ \hline
    feature 1   & 0     & 0     & 0     & 1     & 1         & 1     & \ldots \\ \hline
    feature 2   & 1     & 0     & 1     & 0     & 1         & 1     & \ldots \\ \hline
    \vdots      & \vdots& \vdots& \vdots& \vdots& \vdots    &\vdots & \ldots \\ \hline
\end{tabular}
\label{index}
\end{table}

Поиск производится путем поиска в LSM-дереве, где ключом выступает
\{\textit{feature id + field id + blockid}\}, а значением — блок битмапы.
Конкретный бит однозначно отвечает за ID документа \textit{docId = ID блока * число бит в блоке
+ бит}.

\subsection{Добавление новых блоков взамен мусорных}

Определим пороговое целое значение \textit{dangling} для индекса в первичном
LSM-дереве. Оно равно допустимому количеству \textit{повисших} документов в
блоке. Также добавим в индекс структуру данных, карту \textit{danglingBmap}, для сопоставления
блока в индексе и битмапы, содержащей биты \textit{повисших} документов в блоке.
В случае, если число \textit{повисших} документов в блоке превышает пороговое —
будем считать блок \textit{мусорным}.

При получении запроса на удаление документа:
\begin{itemize}
    \item выполним его логическое удаление из вторичного LSM-индекса.
    \item проставим бит удаленного документа в битмапе, полученную из danglingBmap
    по ключу — блоку, содержащему \textit{повисший} документ.
\end{itemize}

\textit{Замечание}: операция записи в danglingBmap должна быть атомарной для 
избежания состояний гонок и критических секций во время сбора мусора. В нашей
работе используется примитив синхронизации мьютекс.

На этом процедура удаления документа заканчивается до вызова сбора мусора в индексе.
В нашей системе сбор мусора запускается через равные промежутки времени, определяемые 
гиперпараметром системы. Также возможен динамический рассчет промежутка времени,
через который требуется запуск алгоритма, в зависимости от количества запросов на
добавление, удаление и запись.

\textbf{Алгоритм сбора мусора}:
\begin{enumerate}
    \item Для каждого блока в карте \textit{danglingBmap} проверить, превышает
    ли мощность битмапы (число ненулевых битов) допустимое пороговое значение
    для индекса.
    \item В случае отсутствия таких элементов закончить сбор мусора, так
    как он будет неэффективен.
    \item В противном случае: \begin{enumerate}
        \item Для каждого блока, в котором мощность \textit{повисшей} битмапы
        превысила пороговое значение, выполнить операцию \textit{НЕ И} с битмапой,
        полученной из \textit{первичного} индекса. Полученная битмапа не содержит
        удаленных документы. Оставшиеся документы проверить во \textit{вторичном}
        индексе на актуальность ключа (документа).
        \item Присвоить живым документам новый \textit{docId} и обновить
        на них ссылку во \textit{вторичном} индексе.
        \item Продублировать значения битов в битмапах для новых \textit{docId}
        в \textit{первичном} индексе.
        \item Обнулить блок данных для старых \textit{docId}.
        \item Обнулить danglingBmap для старого \textit{blockId}.
    \end{enumerate}
\end{enumerate}

\textbf{TODO:} Указать объем памяти для хранения карты.

\textbf{Вопрос}: реализует ли периодический сбор мусора потребность в своевременном удалении, согласно политики хранения данных?

\subsection{Переиспользование \textit{docId}}

Альтернативный метод — использовать старые \textit{docId} \textit{повисших}
документов вместо создания новых блоков.

Раннее предполагалось, что документы не могут быть удалены или обновлены в
поисковом индексе, а параметр \textit{lastDocId} никогда не уменьшается.

Определим структуру данных, в которых будем хранить \textit{docId} повисших
документов. От структуры мы потребуем быстрый поиск, добавление и удаление
элементов: например, B-дерево (АВЛ, 2-3, $B^{+}$, vEB).
Назовем дерево \textit{danglingTree}.

Процедура удаления документа:
\begin{enumerate}
    \item Обнулим значения битов для каждого признака удаленного документа.
    \item Добавим \textit{docId} документа в \textit{dangling} дерево.
\end{enumerate}

Процедура добавления документа:
\begin{enumerate}
    \item Проверим, не пусто ли \textit{dangling} дерево.
    \item В случае существования \textit{повисшей} ссылки:
    \begin{enumerate}
        \item Удаляем минимальное или произвольное значение \textit{docId} из
        \textit{danglingTree}, предварительно сохранив его.
        \item Записанное значение \textit{docId} присваиваем новому документу.
    \end{enumerate}
    \item В противном случае присваиваем новому документу \textit{docId} равный
    \textit{lastDocId + 1} и инкрементируем значение \textit{lastDocId}.
\end{enumerate}

Битмапы на основе \textit{roaring bitmaps} показывают максимальную эффективность
при определенной разреженности в структуре. Переиспользование \textit{docID}
может нарушить оптимальную структуру блоков, что скажется на производительности.

\textbf{TODO:} вставить карткий абзац про скорость поиска в битмапах в зависимости
от их загрузки (разреженная в len-encoding, массив индексов с единицами O(M), M
- кол-во единиц, плотная битмапа — по очереди O(N)). Рассмотреть разделение данных
в индексе и рассчитать/найти средняя плотность для английского текста.

\subsection{Мгновенное удаление}

Для анализа эффективности алгоритма логично сравнить его с архитектурой без мусора:
при каждом запросе на удаление счищаем все ненулевые биты в битмапах для конкретного
документа.

Данное решение аналогично удалению столбца в разреженной матрице. На это потребуется
множество дополнительных обращений в память, ведь каждый блок строки — это
отдельно лежащая в памяти битмапа для конкретного признака и его значения.

Очевидно, что каждый раз проходить по всем признака индекса слишком затратно. Создадим
дополнительную структуру данных, карту \textit{doc2FieldFeature}, для отображения
документов в набор их признаков и значений. 
%Для последних создадим отдельную структуру, ведь наборы значений признаков логически не пересекаются.

\textit{Замечание}: данная структуру должна заполняться уже после анализа документа на
признаки и последующей обработки их строкового/числового/календарного
представлений в \textit{ID}. Это обусловлено следующими причинами:
\begin{itemize}
    \item Синтаксический анализатор текста может меняться со временем. Таким образом,
    полученное при добавлении документа множество \textit{ID} признаков,
    которые были добавлены в \textit{первичный} индекс, не будет совпадать с
    результирующим множеством \textit{ID} признаков и их значений при смене
    анализатора — поиск выдаст некорректный результат.
    \item На каждую операцию удаления потребуется дополнительная операция перевода
    первоначального представления признаков в их \textit{ID}, что сделает
    модель менее эффективной по времени.
    \item Хранение признаков в виде, полученном из документа, потребует больше
    памяти, чем их представление в виде \textit{ID}.
\end{itemize}

Таким образом, при добавлении документа запишем в описанную выше структуру набор
\textit{ID} признаков и значений, которые вставим в \textit{первичный} индекс.

Рассмотрим структуру элемента \textit{первичного} индекса в общем случае. Элемент
\textit{entry} состоит из идентификатора признака, его поля, блока битмапы,
содержащей множество документов и специального маркера удаления
\textit{tombstone}. Для реализации качественного мгновенного удаления добавим в
структуру \textit{entry} битмапу удаленных документов.

При получении запроса на удаление документа для каждого его признака и
значения из отображения \textit{doc2FieldFeature} выполним вставку в
\textit{первичный индекс} элемента с указанными признаком, полем, блоком
(вычисленным для нужного документа) и битмапой, состоящий из 1 бита — позиции
документа в блоке. Данный элемент сольется с элементом с такими же признаком,
значением и блоком в индексе.

При вставке в индекс в случае сбора мусора мы выполняли операцию побитового
\textit{ИЛИ} для двух битмап, тем самым, сливая документы с добавленными ранее.
Сейчас же требуется иной алгоритм. При слиянии нового и старого элементов
индекса:
\begin{enumerate}
    \item Битмапа удаленных документов для результирующего элемента индекса
    получится результатом побитовой операции \textit{ИЛИ} битмап удаленных
    документов для старого и нового элементов. Таким образом, мы учитываем
    документы, удаленные за всю историю существования документа.
    \item Главная битмапа результирующего элемента образуется после применения
    операции побитового \textit{ИЛИ} нового и старого элементов индекса. Далее к 
    полученной битмапе применяется операция побитового \textit{НЕ И} с полученной
    выше битмапой удаленных документов. Таким образом, все добавленные когда-либо
    документы будут очищены от когда-либо удаленных документов. 
\end{enumerate}

Удаление может называться мгновенным, так как вставка бита в индекс и операция
слияния происходит сразу же при удалении вместо вставки лишь макера удаления и
удаления лишь при записи на диск.

\textbf{TODO}: Рассчитать объем дополнительной памяти для хранения индексов в блоке.
