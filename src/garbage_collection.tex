\newpage
\section{Циклический сборщик мусора}
\label{section:dangling}

Рассмотрим поисковую систему, хранилище которой основано на LSM-дереве,
использующем битмап индексы в качестве значений. Назовем \textit{первичным}
LSM-индексом индекс, состоящий из битмап документов с определенными признаками,
а \textit{вторичным} — индекс, используемый для фактического поиска документов
по \textit{docID}. Таким образом, изначальный поиск документов осуществляется в
\textit{первичном} индексе, а найденные документы проверяются на актуальность
во \textit{вторичном}.

Документ при добавлении анализируется и делится на значимые признаки вида
\textit{дата}, \textit{текст}, \textit{маркер} и другие. Каждый признак
принимает множество уникальных значений, а каждое значение однозначно определяется
\textit{ID} признака и значения. Каждому документу присваивается уникальный
\textit{docID}, соответствующий единственному объекту.

Как было указано ранее (см. с.~\pageref{table}), данные можно представить в виде
таблицы, где строка отвечает за определенный признак и его значение, а столбец
— за документ. Из-за огромного количества документов и меньшего количества
уникальных значений признаков битмапы обычно сильно разрежены, поэтому длинная
строка битмапы поделена на блоки равного размера $(\sim 2^{x})$ и хранится в
сжатом виде.

\begin{table}[H]
\caption{Логическое представление индекса}
\centering
\small
\singlespacing
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
    \hline
                &\multicolumn{3}{c|}{block1}&\multicolumn{3}{c|}{block2}& \ldots \\ \hline
                & doc1  & doc2  & doc3      & doc4  & doc5      & doc6  & \ldots \\ \hline
    feature 1   & 0     & 0     & 0         & 1     & 1         & 1     & \ldots \\ \hline
    feature 2   & 1     & 0     & 1         & 0     & 1         & 1     & \ldots \\ \hline
    \vdots      & \vdots& \vdots& \vdots    & \vdots& \vdots    &\vdots & $\ddots$ \\ \hline
\end{tabular}
\label{index}
\end{table}

Поиск производится путем поиска в LSM-дереве, где ключом выступает
\{\textit{feature id + field id + blockid}\}, а значением — блок битмапы.
Конкретный бит однозначно отвечает за ID документа \textit{docId = ID блока
$\cdot$ число бит в блоке + бит}.

\subsection{Добавление новых блоков взамен мусорных}

Определим пороговое целое значение \textit{dangling} для индекса в первичном
LSM-дереве. Оно равно допустимому количеству \textit{повисших} документов в
блоке. Также добавим в индекс структуру данных, карту \textit{danglingBmap}, для
отображения блоков в индексе в битмапы, содержащие биты \textit{повисших}
документов в блоке. В случае, если число \textit{повисших} документов в блоке
превышает пороговое — будем считать блок \textit{мусорным}.

При получении запроса на удаление документа:
\begin{itemize}
    \item выполним его логическое удаление из вторичного LSM-индекса.
    \item проставим бит удаленного документа в битмапе, полученную из
    \textit{danglingBmap} по ключу — блоку, содержащему \textit{повисший} документ.
\end{itemize}

\textit{Замечание}: операция записи в danglingBmap должна быть атомарной для 
избежания состояний гонок и критических секций во время сбора мусора. В нашей
работе используется примитив синхронизации мьютекс.

На этом процедура удаления документа заканчивается до вызова сбора мусора в индексе.
В нашей прототипе сбор мусора запускается через равные промежутки времени, определяемые 
гиперпараметром системы. Также возможен динамический рассчет промежутка времени,
через который требуется запуск алгоритма, в зависимости от количества запросов на
добавление, удаление и запись.

\textbf{Алгоритм сбора мусора}:
\begin{enumerate}
    \item Для каждого блока в карте \textit{danglingBmap} проверить, превышает
    ли мощность битмапы (число ненулевых битов) допустимое пороговое значение
    для индекса.
    \item В случае отсутствия таких элементов закончить сбор мусора, так
    как он будет неэффективен.
    \item В противном случае: \begin{enumerate}
        \item Для каждого блока, в котором мощность \textit{повисшей} битмапы
        превысила пороговое значение, выполнить операцию \textit{НЕ И} с битмапой,
        полученной из \textit{первичного} индекса. Полученная битмапа не содержит
        удаленных документов. Оставшиеся документы проверить во \textit{вторичном}
        индексе на актуальность ключа (документа).
        \item Присвоить живым документам новый \textit{docId} и обновить
        на них ссылку во \textit{вторичном} индексе.
        \item Продублировать значения битов в битмапах для новых \textit{docId}
        в \textit{первичном} индексе.
        \item Удалить блок данных для старых \textit{docId}.
        \item В конце сбора мусора обнулить  \textit{danglingBmap} для старого
        \textit{docId}.
    \end{enumerate}
\end{enumerate}

Подсчитаем объем памяти, необходимый для хранения дополнительной карты
\textit{danglingBmap}. Согласно \cite{Roaring:2019} несжатое битовое множество
на $10^6$ документов занимается порядка 100kB памяти. Тогда для 20MB текста
(документов) и размера блока в $10^6$ элементов потребуется в худшем случае
(все блоки не сжаты) 2MB дополнительной памяти для карты удаленных документов.
Этот объем памяти можно хранить в быстрой памяти, иногда выполняя сериализацию
в долгосрочную память. В случае же $10^9$ документов потребуется дополнительная
структура для удобного поиска и хранение во внешней памяти.

\subsection{Переиспользование \textit{docId}}

Альтернативный метод — использовать старые \textit{docId} \textit{повисших}
документов вместо создания новых блоков.

Раннее предполагалось, что документы не могут быть обновлены в поисковом
индексе, а параметр \textit{lastDocId} никогда не уменьшается.

Определим структуру данных, в которых будем хранить \textit{docId} повисших
документов. От структуры мы потребуем быстрый поиск, добавление и удаление
элементов: например, B-дерево (АВЛ, 2-3, $B^{+}$, vEB).
Назовем дерево \textit{danglingTree}.

Процедура удаления документа:
\begin{enumerate}
    \item Обнулим значения битов для каждого признака удаленного документа.
    \item Добавим \textit{docId} документа в \textit{dangling} дерево.
\end{enumerate}

Процедура добавления документа:
\begin{enumerate}
    \item Проверим, не пусто ли \textit{dangling} дерево.
    \item В случае существования \textit{повисшей} ссылки:
    \begin{enumerate}
        \item Удаляем минимальное или произвольное значение \textit{docId} из
        \textit{danglingTree}, предварительно сохранив его.
        \item Записанное значение \textit{docId} присваиваем новому документу.
    \end{enumerate}
    \item В противном случае присваиваем новому документу \textit{docId} равный
    \textit{lastDocId + 1} и инкрементируем значение \textit{lastDocId}.
\end{enumerate}

Гибридные подходы, как, например, \textit{roaring bitmaps} используют одновременно
три разных представления для битмапов и балансируют между ними, чтобы
максимизировать производительность и минимизировать потребление памяти \cite{Roaring:2019}.
Однако при таком подходе в индексе окажется много плотных битмап, и операции над
ними занимают линейное от длины битмапы вместе с нулями время, причём значительная
часть полученных битов потом фильтруется, что требует дополнительных структур
данных или просмотров LSM-индекса.

\subsection{Мгновенное удаление}

Для анализа эффективности алгоритма логично сравнить его с архитектурой без мусора:
при каждом запросе на удаление счищаем все ненулевые биты в битмапах для конкретного
документа.

Данное решение аналогично удалению столбца в разреженной матрице. На это потребуется
множество дополнительных обращений в память, ведь каждый блок строки — это
отдельно лежащая в памяти битмапа для конкретного признака и его значения.

Очевидно, что каждый раз проходить по всем признака индекса слишком затратно. Создадим
дополнительную структуру данных, карту \textit{doc2FieldFeature}, для отображения
документов в набор их признаков и значений. 
%Для последних создадим отдельную структуру, ведь наборы значений признаков логически не пересекаются.

\textit{Замечание}: данная структуру должна заполняться уже после анализа документа на
признаки и последующей обработки их строкового/числового/календарного
представлений в \textit{ID}. Это обусловлено следующими причинами:
\begin{itemize}
    \item Синтаксический анализатор текста может несколько меняться со временем,
    чтобы он оставался корректным с точки зрения пользователя. Однако,
    полученное таким образом при добавлении документа множество \textit{ID} признаков,
    которые были добавлены в \textit{первичный} индекс, не будет точно совпадать с
    результирующим множеством \textit{ID} признаков при смене анализатора.
    \item На каждую операцию удаления потребуется дополнительная операция перевода
    первоначального представления признаков в их \textit{ID}, что потребует лишнего
    времени.
    \item Хранение признаков в виде, полученном из документа, потребует больше
    памяти, чем их представление в виде \textit{ID}.
\end{itemize}

Таким образом, при добавлении документа запишем в описанную выше структуру набор
\textit{ID} признаков и значений, которые вставим в \textit{первичный} индекс.

Рассмотрим структуру элемента \textit{первичного} индекса в общем случае. Элемент
\textit{entry} состоит из идентификатора признака, его значения, блока битмапы,
содержащей множество документов и специального маркера удаления
\textit{tombstone}. Для реализации качественного мгновенного удаления добавим в
структуру \textit{entry} битмапу удаленных документов.

При получении запроса на удаление документа для каждого его признака и
значения из отображения \textit{doc2FieldFeature} выполним вставку в
\textit{первичный} индекс элемента с указанными признаком, зачением, блоком,
вычисленным для нужного документа и битмапой, состоящей из 1 бита — позиции
документа в блоке. Данный элемент сольется с элементом с такими же признаком,
значением и блоком в индексе.

При вставке в индекс в случае сбора мусора мы выполняли операцию побитового
\textit{ИЛИ} для двух битмап, тем самым, сливая документы с добавленными ранее.
Сейчас же требуется иной алгоритм. При слиянии нового и старого элементов
индекса:
\begin{enumerate}
    \item Битмапа удаленных документов для результирующего элемента индекса
    получится результатом побитовой операции \textit{ИЛИ} битмап удаленных
    документов для старого и нового элементов. Таким образом, мы учитываем
    документы, удаленные за всю историю существования документа.
    \item Главная битмапа результирующего элемента образуется после применения
    операции побитового \textit{ИЛИ} нового и старого элементов индекса. Далее к 
    полученной битмапе применяется операция побитового \textit{НЕ И} с полученной
    выше битмапой удаленных документов. Таким образом, все добавленные когда-либо
    документы будут очищены от когда-либо удаленных документов. 
\end{enumerate}

Удаление может называться мгновенным, так как вставка бита в индекс и операция
слияния происходит сразу же при удалении вместо вставки лишь макера удаления и
удаления лишь при записи на диск и долго слияния в множеством структур.

\subsection{Теоретическое сравнение затраченных ресурсов}

\subsubsection{Алгоритм сбора мусора}

Допустим, мы добавили $N$ документов в индекс, удалили $D$ документов.
До момента сбора мусора мы проставим $D$ дополнительных бит в \textit{danglingBmap}.
Мы заполним биты в $b$ блоках, что добавит $b$ значений блоков в карту.
Итого получится, $D + 32\cdot b = M$ бит, так как мы
храним значения блоков в виде \textit{uint32}. Стоит заметить, что $b$ будет
наименьшим при удалении последовательных документых.

\textbf{TODO}: учесть sizeof(битмапы).

Следовательно, до сбора мусора наша карта будет занимать дополнительных $M$ байт.
При сборе мусора рассмотрим лучший и худший случаи: количество \textit{мусорных}
блоков зависит от порога \textit{dangling} для блока и расположения удаленных
документов в индексе.

В лучшем случае, при удалении пордряд идущих документов получим, что в индексе
имеется $\left\lfloor\frac{D}{\text{block size}}\right\rfloor$ мусорных блоков.
Последний блок учитываем, если $(D \% \text{block size}) \geq \frac{dangling}{\text{block size}}$.

В худшем случае удаляются по одному биту с
каждого блока. В индексе имеется всего $\left\lceil\frac{N}{\text{block size}}\right\rceil = B$ блоков. Таким
образом, в случае $\frac{D}{B} \leq \frac{dangling}{\text{block size}}$ удаления
при сборе мусора не произойдет вовсе, ведь во всех блоках будет недостаточно
удаленных документов для очистки.

Таким образом, при сборе мусора будет выявлено
$$\left[0;\left\lceil\frac{D}{\text{block size}}\right\rceil\right] = b$$
мусорных блоков. Каждый из $b$ блоков будет удален с перераспределением живых
элементов в новые блоки. Общее число живых элементов в мусорном блоке $b \cdot
\text{block size} - D$, и алгоритм создаст $$\left\lceil\frac{b \cdot
\text{block size} - D}{\text{block size}}\right\rceil = \left\lceil b -
\frac{D}{block size}\right\rceil = NB$$ новых блоков.

Таким образом, после выполнения сбора мусора мы избавимся от $$M - NB\cdot
\text{block size} = D + 32\cdot b - b \cdot \text{block size} - D = b \cdot
(32 - \text{block size})$$ бит, где $b \in \left[0;\left\lceil\frac{D}{\text{block size}}\right\rceil\right]$

Таким образом, алгоритм будет эффективен по памяти при \textit{block size} $\geq 32$ и $b \ge 0$.

\subsubsection{Алгоритм <<мгновенного удаления>>}

Допустим, мы добавили $N$ документов в индекс и удалили $D$ документов. Мы
проставим $D$ дополнительных бит в битмапах удаленных элементов для нужных блоков.
Эти биты заполнятся в $b$ блоках, что добавит $b$ битмап в \textit{первичный}
индекс. Итого получится, $D + b \cdot \text{размер битмапы} = M$.

Также учитываем размер \textit{doc2FieldFeature}: $D \cdot \text{число уникальных
признаков в среднем для документа}$. Согласно \cite{Features:2020}, в среднем в
1Gb данных из $4\cdot 10^5$ документов, находится около $18 \cdot 10^7$ различных
признаков. Обозначим $C = \frac{18 \cdot 10^7}{4\cdot 10^5}$ как среднее количество
уникальных токенов в одном документе. Таким образом, для каждого из $D$ удаленных
документов будет выделено $C \cdot D$ дополнительной памяти. Учитывая, что
\textit{ID} признака и его значений в нашей работе 32-битные числа, то получается,
что данная структура занимает $32\cdot C\cdot D$ дополнительных бит.

Самое важное, что данная структура не уничтожается и переносится на диск для
удаления элементов из более взрослых уровней, что делает менее эффективной по
использованю памяти, чем алгоритм сбора мусора.

\textbf{TODO}: следует ли учесть размер нулевой битмапы, который создается для
каждого блока из $\left\lceil\frac{N}{\text{block size}}\right\rceil \cdot C$.