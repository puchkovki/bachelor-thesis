\newpage
\section{Постановка задачи}

Рассмотрим поисковую систему, использующие инвертированные индексы в виде
\textit{битмап} для полнотекстового поиска.
\textit{Индекс} — это отдельная структура данных, которая поддерживается и
обновляется в дополнение к основным данным.
Она используется для ускорения поиска: без индексов поиск требовал бы полного
прохода по данным (процесс, называемый full scan), и этот процесс имеет линейную
алгоритмическую сложность. Но базы данных обычно содержат большое количество
данных и линейная сложность — это слишком медленно.

\textit{Инвертированный индекс} – это полнотекстовый индекс, хранящий для каждого
ключа отсортированный список адресов записей таблицы, которые содержат данный ключ.

\textit{Битмап индексация} – метод битовых индексов, заключающийся в создании
битовых последовательностей $0$ и $1$ для каждого возможного значения столбца, где
каждому биту соответствует строка с индексируемым значением, а его значение
равно 1 тогда и только тогда, когда запись, соответствующая позиции бита,
содержит индексируемое значение для данного столбца или свойства.

\textit{Битмап-индексы} используют \textit{битмапы} для того, чтобы заимплементить
поисковый индекс. Таким образом, индекс состоит из одной или нескольких
\textit{битмап}, представляющих какие-либо сущности (типа животных) и их свойства
или параметры (вес, рост, породу, цвет глаз и т. д.), и из алгоритма,
использующего битовые операции (AND, OR, NOT) для ответа на поисковый запрос.

Изначально на вход поисковой системе поступает поисковый запрос, обычно в виде
текста. Запрос анализируется и разбирается (парсится) на признаки/фичи,
где конкретный признак отвечает за определенное свойство: слово из документа,
дата публикации, маркер статьи и прочее.
Далее выполняется поиск требуемых признаков в LSM-дереве, где ключом будет заданный
признак и его значение/поле, а значением — битмапа. Полученные битмапы
подставляются как переменные в булеву формулу, составленную по изначальному запросу.

Битмапы, хранящие в себе наличие либо отсутствие у документов определенных признаков 
обычно сильно разрежены. Поэтому они хранятся в сжатом виде, а для удобства
использования поделены на блоки равного размера. Сами данные в поисковом дереве
расположены по блокам, которые однозначно определены отступом. Таким образом,
каждый блок можно представить в виде двухмерной таблицы, в строке которой
находятся поле + признак, а в столбце — документ.

Документы, веб-страницы и другие объекты в сети Интернет, а следовательно, и в
исследуемом поисковом LSM-дереве, часто теряют свою актуальность, перестают
отвечать на запросы либо просто удаляются по другим причинам \cite{Dangling:2018}:
\begin{enumerate}
    \item Реорганизация сайта. Изменение структуры сайта или переезд на другой домен,
    без настройки постраничных автоматических переходов. Например, переезд сайта с 
    HTTP на HTTPS протокол.
    \item Удаление части сайта или отдельных страниц. При этом ссылки на страницы
    остались. Очень популярно среди интернет-магазинов — когда товара нет в наличии
    или он снят с производства, его удаляют.
    \item Опечатки в URL при добавлении ссылки. Например, структура URL-адресов
    подразумевает в конце слеш, а на сайте добавлена ссылка без слеша.
\end{enumerate}

Полученная битмапа из первого поискового индекса, описанного выше, представляет
собой набор \textit{ID} объектов.
Далее используется вторичный LSM-индекс, который производит поиск актуальных 
объектов по их \textit{ID}. В случае удаления объекта поле \textit{tombstone} его
структуры помечается активным и не выдается вторичному поисковому индексу.
Таким образом, при множестве \textit{повисших ссылок} на объекты при поисковом запросе
выполняется множество бесполезных запросов в LSM-дерева, что, в случае большого
количества данных, окажет значимый эффект на производительность системы в целом.

Современные структуры данных для хранения огромного количества объектов требуют
дополнительную внешнюю память. Классическая структура данных с использованием механизма
внешней памяти — LSM-дерево. Простая версия LSM-дерева — двухуровневое дерево — состоит
из двух древоподобных структур $C_0$ и $C_1$. $C_0$ меньше по размеру и хранится
целиком в оперативной памяти, а $C_1$ находится в энергонезависимой памяти. Новые
записи вставляются в $C_0$. Если после вставки размер C0 превышает некоторое заданное
пороговое значение, непрерывный сегмент удаляется из C0 и сливается с C1 на устройстве
постоянного хранения. Хорошая производительность достигается из-за того, что деревья
оптимизированы под их хранилище, а слияние осуществляется эффективно и группами по
нескольку записей.

Удаление в LSM-деревьях происходит логически путем добавления специального поля,
\textit{tombstone}. После вставки в $C_0$ запись будет реально удалена лишь после
того, как \textit{tombstone} достигнет последнего уровня дерева на диске. Таким
образом, время фактического удаления записи зависит напрямую от алгоритма размещения
и сжатия данных в деревьях, плотности записи и удаления объектов в базе данных, количества уровней деревьев в структуре и размеров самих деревьев. 

Во-первых, наличие \textit{повисших записей} ведет к неэффективному использованию
пространства на диске, что вызывает \textit{усиление пространства}
(write amplification). Во-вторых, записи постоянно перезаписываются при слиянии,
что влечет \textit{усиление записи} (write amplification). В-третьих, наличие
\textit{повисших записей} остаются в фильтрах Блума, что увеличивает вероятность
ошибок первого рода. В-четвертых, без ограничений на время удаления, внешние удаления могут привести к высокой задержке постоянных удалений, что является может привести
к проблемам безопасности. \cite{Lethe:2020}

Целью данной работы является описание метода эффективного сбора  мусора в блоках
битмап. Требуемые свойства:
\begin{enumerate}
    \item Возможность хранения части индекса во внешней памяти. Это требование вытекает
    из необходимости индексации данных большого размера и относительной дороговизны
    оперативной памяти.
    \item Высокая скорость удаления объектов. В случае отложенного удаления до момента
    слияния с структурами на диске при большом количестве удаленных объектов множество
    операций в память будут напрасными, а значит, требуется своевременное удаление
    элементов путем периодического сбора мусора.
    \item Отсутствие модификации метаданных на месте: структуры индекса по возможности должны добавлять новые документы вместо модификации старых.
    \item Эффективное исполнение групповых запросов на удаление и запись. 
\end{enumerate}

Из цели работы вытекают следующие задачи:
\begin{enumerate}
    \item Исследовать существующие методы сбора мусора данных в поисковых системах
    и поисковых структур данных.
    \item Разработать метод с требуемыми свойствами.
    \item Произвести анализ иных свойств метода, его преимуществ и недостатков.
    \item Программно реализовать метод и произвести экспериментальную апробацию реализации. 
    % \item Сравнить скорость работы алгоритма с методом мгновенного удаления (лобовым решением).
\end{enumerate}