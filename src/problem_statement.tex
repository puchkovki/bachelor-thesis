\newpage
\section{Постановка задачи}

\subsection{Битовые индексы для полнотекстового поиска}

Рассмотрим поисковую систему, использующую инвертированный битовый индекс
для полнотекстового поиска. \textit{Индекс} — это отдельная структура данных,
которая поддерживается и обновляется в дополнение к основным данным.
Она используется для ускорения поиска: без индексов поиск требовал бы полного
прохода по данным, а этот процесс имеет линейную от размера входных данных
алгоритмическую сложность. Но базы данных обычно содержат большое количество
данных, и линейный поиск будет слишком длительным и неэффективным.

Обычно каждый уникальный элемент данных в структурах отображается в \textit{множество}
индексов. Однако если мы рассмотрим общий подход для хранения множеств целых
чисел, то даже для $n$ элементов, которые занимают в системе 32 бита, общий
размер множества $[i_1, \cdots, i_{n}]$ будет равным $32 \cdot n$ бита.
Очевидно, что при большом количестве данных данный подход неэффективен.

Используя же битовые множества, мы потратим $i_{n}$ бит — решение станет
неэффективным лишь при $i_{n} \ge 32 \cdot n $. Следовательно, на разреженных
данных алгоритм будет менее продуктивнее обычных множеств. Однако алгоритмы
сжатия не стоят на месте, что позволяет увеличить производительность использования
битовых множеств.

\textit{Битовая карта}, \textit{битмапа} — последовательность (массив) битов.
\textit{Битмап-индексы} используют \textit{битмапы} для реализации поискового
индекса. Таким образом, индекс состоит из одной или нескольких \textit{битмап},
представляющих какие-либо объекты, например людей, и их свойства
или признаки, например вес, рост, пол, цвет глаз и т. д., и из алгоритма,
использующего битовые операции (ИЛИ, И, НЕ) для ответа на поисковый запрос.

\textit{Инвертированный индекс} – это полнотекстовый индекс, хранящий для каждого
ключа отсортированный список адресов записей таблицы, которые содержат данный ключ.
\textit{Битмап индексация} — способ доступа к элементам множества, таким образом,
что для каждого признака в инвертированном индексе определяется битовая
строка, вектор из нулей и единиц, где номер позиции в векторе однозначно
соответствует номеру объекта (документа), причём это соответствие одинаково для
всех строк в индексе, и единица на позиции значит, что у объекта имеется данный 
признак, а ноль — что отсутствует.

Для улучшения эффективности хранения данных используются различные алгоритмы
сжатия, например, кодирование на основе длин серий. Он подсчитывает число повторов и
записывает их перед повторяющимся символом. Такое кодирование эффективно для
данных, содержащих большое количество серий, например, для простых графических
изображений либо для кодирования битовых индексов либо двоичных данных
$\{0, 1\}$ в файлах с двоичной информацией.

В естественных науках значения исследуемых величин часто непрерывны. Хранение
каждого уникального значения переменной — излишне затратная операция с точки
зрения памяти, поэтому используется метод группировки данных, который разделяет
непрерывный ряд значений физической величины на
дискретное число непересекающихся ячеек. Таким образом, зная номер ячейки, мы
можем восстановить значение переменной с требуемой точностью и получить выигрыш
по памяти в хранении дискретного набора величин, в отличие от непрерывного.
Если сопоставить каждой ячейке конкретный бит и использовать битмап индексацию,
то получится алгоритм, применяемый в обработке экспериментальных данных в физике
высоких энергий, биологии, моделировании климата и прочих естественных науках.

Интересующая нас сфера применения метода индексации, описанного выше, —
полнотекстовый поиск. Изначально на вход поисковой системе поступает поисковый
запрос, обычно в виде текста. Запрос анализируется и делится на признаки,
отвечающие за определенное свойство: слово из документа, дата публикации, маркер
статьи и прочее.

После получения набора отобранных из запроса признаков выполняется их поиск в
структуре данных, где ключом выступает заданный признак, а значением — \textit{битмапа}.
Собранные карты далее подставляются как переменные в булеву формулу,
составленную по изначальному запросу. Ответом на запрос будет значение формулы,
а именно, \textit{битмапа}. Ненулевые биты в ней указывают на документы, содержащие
запрошенную информацию и требуемые для возврата пользователю в качестве
ответа на поисковый запрос.

\textit{Битмапы}, хранящие в себе наличие либо отсутствие у документов определенных
признаков обычно сильно разрежены, поэтому хранятся в сжатом виде. В поисковых
системах обычно миллиарды документов, и выполнение битовых операций над битмапами
подобной длины непозволительно долго. Поэтому \textit{roaring bitmaps}
\cite{Roaring:2018} делит данные на блоки равного размера, которые однозначно
определены отступом в самой поисковой структуре. Таким образом, каждый блок можно
представить в виде двумерной таблицы: ее строки отвечают за признаки,
а столбцы — за документы.\label{table}

Как было сказано ранее, \textit{roaring bitmaps} делит данные на блоки размера
$2^{16} = 65535$. Такие блоки называются контейнеры и делятся на 3 категории:
\begin{enumerate}
    \label{bitmap}
    \item Массив-контейнер. Хранится отсортированный массив данных без использования
    битмап. Поиск организуется двоичным поиском. При превышении размера структуры
    значения 4096, массив-контейнер преобразуется в битовый контейнер.

    Таким образом, двоичный поиск среди 4096 элементов займет $\leq \log_2{4096}
    = 12$ операций доступа. В кодированном виде занимает 8192 байта.
    \item Битовый контейнер. Хранится как 1024 слова по 64 бита (8kB) без
    использования сжатия. Память выделяется статически при объявлении. Используются
    64-битные инструкции процессора, что обеспечивает хорошую производительность.

    Занимает $2 \cdot c+2$ байта, где $c$ — мощность битмапы.
    \item Run контейнер, использующий кодирование на основе длин серий. Состоит
    из массива пар. Первое значение пары содержит исходное значение, а второе —
    длину <<пробега>>, в котором все элементы присутствуют в исходных данных.

    Занимает $2+4\cdot r$ байта, где $r$ — число <<пробегов>>.
\end{enumerate}

\subsection{LSM-дерево}

Современные структуры данных для хранения множества объектов часто требуют
дополнительную внешнюю память. Классическая структура данных с использованием механизма
внешней памяти, а также поисковая структура, используемая в нашем прототипе —
LSM-дерево. Оно состоит из древоподобных структур $C_0$ и $C_i, i \ge 1$.
$C_0$ меньше по размеру и хранится
целиком в оперативной памяти, а $C_i$ находятся в энергонезависимой памяти. Новые
записи вставляются в $C_0$. Если после вставки размер $C_0$ превышает некоторое заданное
пороговое значение, непрерывный сегмент удаляется из $C_0$ и сливается с $C_1$ на устройстве
постоянного хранения. Хорошая производительность достигается из-за того, что деревья
оптимизированы под их хранилище, а слияние осуществляется эффективно и группами по
нескольку записей.

\subsection{Удаление из индекса}

При работе с разнообразной информацией удаление данных из хранилища определяется
в первую очередь политикой хранения данных. Согласно закону о забвении и его
вариациям, любые данные должны быть немедленно удалены по запросу пользователя,
которому они принадлежат. Отложенное удаления может повлечь за собой юридическую
ответственность.

Документы, веб-страницы и другие объекты в сети Интернет, а следовательно, и в
исследуемом поисковом LSM-дереве, часто теряют свою актуальность, перестают
отвечать на запросы либо просто удаляются по другим причинам \cite{Dangling:2018}:
\begin{enumerate}
    \item Перестройка сайта. Изменение структуры сайта или переезд на другой
    домен без установки постраничных автоматических переходов. Например,
    переезд сайта с HTTP на HTTPS протокол.
    \item Удаление отдельных страниц сайта, что нередко среди интернет-магазинов.
    Товара нет в наличии или он снят с производства — его удаляют, при этом 
    ссылки на страницы остаются.
    \item Опечатки в адресах ресурсов при добавлении ссылок. Например, структура
    URL-адресов подразумевает в конце косую черту, а на сайт добавляется ссылка
    без нее.
\end{enumerate}

В поисковых структурах данных удаление — очень дорогостоящая по времени и
памяти операция. Удаление в
LSM-деревьях происходит логически путем добавления специального элемента, маркера 
удаления, \textit{tombstone}. После вставки в $C_0$ запись будет реально удалена
лишь после того, как отметка об удалении достигнет последнего уровня дерева на
диске \cite{ONeil:1996}. Таким образом, время фактического удаления записи зависит напрямую от
алгоритма размещения и сжатия данных в деревьях, плотности записи и удаления
объектов в базе данных, количества уровней деревьев в структуре и размеров самих
деревьев. В нашей реализации при мгновенном удалении всего одного документа в
битмапе требуется совершить либо $N$ операций, где $N$ — количество всех признаков
в индексе (т.е. очистить конкретный бит в каждой битовой строке), либо $N_d$,
где $N_d$ — количество признаков у $d$-го документа, причём в этом случае требуется
дополнительная память для хранения отображения документов в признаки либо 
дополнительная операция чтения и разбора документа на признаки в процессе удаления.

Проблема большого числа недействительных документов проявляется, когда после
булевой формулы \textit{битмапа} передается в дополнительный индекс, который производит
поиск актуальных объектов по их \textit{ID}. В случае удаления объекта поле
\textit{tombstone} его структуры помечается активным и не выдается вторичному
поисковому индексу. Таким образом, при множестве \textit{повисших ссылок} на
объекты во время поиска выполняется немало лишних запросов в память, что, в
случае большого количества данных, скажется на производительности системы в целом.

Во-первых, наличие \textit{повисших ссылок} ведет к неэффективному использованию
пространства на диске, что вызывает \textit{усиление пространства}. Во-вторых,
удаленные элементы постоянно перезаписываются при слиянии, что влечет
\textit{усиление записи}. В-третьих, наличие \textit{повисших записей} сказывается
на качестве работы фильтров Блума, применяемых для проверки наличия ключей в
индексе, и увеличивает вероятность ошибки первого рода. В-четвертых, без
ограничений на время исполнения операции, внешние удаления могут привести к высокой задержке,
что может привести к проблемам безопасности \cite{Lethe:2020}.
\label{amplification}

\subsection{Требуемые свойства алгоритма и поставленные задачи}

Целью данной работы является описание метода эффективного сбора мусора в LSM-
дереве c значениями — блоками битмап. \textbf{Требуемые свойства}:
\begin{enumerate}
    \item Возможность хранения части индекса во внешней памяти. Это требование вытекает
    из необходимости индексации данных большого размера и относительной дороговизны
    оперативной памяти.
    \item Реализация периодического запуска. Период операции должен зависеть от нагрузки 
    на сервер.
    \item Отсутствие необходимости хранения обратного отображения \{документ\} $\rightarrow$
    \{признак + значение\}.
    \item Высокая скорость удаления объектов. Требуется произвести не более двух операций
    вставки с учетом проставления маркера удаления на каждый очищаемый блок.
\end{enumerate}

Из цели работы вытекают следующие задачи:
\begin{enumerate}
    \item Исследовать существующие методы сбора мусора данных в поисковых системах
    и поисковых структурах данных.
    \item Разработать метод с требуемыми свойствами.
    \item Произвести анализ иных свойств метода, его преимуществ и недостатков.
    \item Программно реализовать метод и произвести экспериментальную апробацию реализации. 
    \item Сравнить скорость работы алгоритма с методом мгновенного удаления: отсутствием накопления
    мусора в системе в принципе.
\end{enumerate}